from __future__ import annotations
from pydantic import BaseModel, Field, model_validator
from typing import Literal, Any, Annotated
import uuid

# 1. Shared Types
Role = Literal["system", "user", "assistant", "tool"]


# 2. Content Blocks (For Multimodal User Messages)
class TextContent(BaseModel):
    type: Literal["text"] = "text"
    text: str


class ImageContent(BaseModel):
    """
    Internal representation of an image.
    Ideally normalized to base64 or a stable URL before reaching here.
    """

    type: Literal["image_url"] = "image_url"
    url: str  # data:image/png;base64,... or https://...
    detail: Literal["auto", "low", "high"] = "auto"


class AudioContent(BaseModel):
    """
    Internal representation of input audio.
    """

    type: Literal["input_audio"] = "input_audio"
    data: str  # Base64 encoded audio
    format: Literal["wav", "mp3"] = "mp3"


# Union for user content
UserContent = str | list[TextContent | ImageContent | AudioContent]


# 3. Tool Primitives
class ToolCall(BaseModel):
    """
    Represents a request from the Assistant to execute a function.
    """

    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    type: Literal["function"] = "function"
    function_name: str
    arguments: dict[str, Any]


# 4. Concrete Message Types


class SystemMessage(BaseModel):
    """
    System instructions.
    """

    role: Literal["system"] = "system"
    content: str


class UserMessage(BaseModel):
    """
    Messages sent by the human.
    Supports simple strings or complex multimodal chains (Text + Image).
    """

    role: Literal["user"] = "user"
    content: UserContent
    name: str | None = None


class AssistantMessage(BaseModel):
    """
    Messages generated by the LLM.
    Can contain text (content), internal thought (reasoning), or actions (tool_calls).
    """

    role: Literal["assistant"] = "assistant"

    # The final visible answer
    content: str | None = None

    # The hidden internal chain-of-thought (DeepSeek/Claude 3.7 style)
    reasoning: str | None = None

    # The actions to take
    tool_calls: list[ToolCall] | None = None

    # Validation: Must have at least one payload
    @model_validator(mode="after")
    def validate_structure(self) -> AssistantMessage:
        if not any([self.content, self.tool_calls, self.reasoning]):
            raise ValueError(
                "AssistantMessage must have at least one of: content, tool_calls, or reasoning."
            )
        return self


class ToolMessage(BaseModel):
    """
    The result of a tool execution, fed back to the LLM.
    """

    role: Literal["tool"] = "tool"
    content: str  # The output of the tool (usually JSON stringified)
    tool_call_id: str  # Links this result to the Assistant's ToolCall.id
    name: str | None = None  # Optional: name of the tool function


# 5. The Discriminated Union
# This is the type you import and use in lists: list[Message]
Message = Annotated[
    SystemMessage | UserMessage | AssistantMessage | ToolMessage,
    Field(discriminator="role"),
]
