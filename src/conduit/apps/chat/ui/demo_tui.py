from __future__ import annotations
import io
import shutil
import sys
from typing import override, TYPE_CHECKING

from rich.console import Console, RenderableType
from rich.markdown import Markdown

from prompt_toolkit import Application
from prompt_toolkit.buffer import Buffer
from prompt_toolkit.layout.containers import HSplit, Window
from prompt_toolkit.layout.controls import BufferControl, FormattedTextControl
from prompt_toolkit.layout.layout import Layout
from prompt_toolkit.layout.dimension import Dimension
from prompt_toolkit.key_binding import KeyBindings
from prompt_toolkit.formatted_text import ANSI
from prompt_toolkit.widgets import Frame
from prompt_toolkit.styles import Style as PtStyle

from conduit.apps.chat.ui.input_interface import InputInterface
from conduit.apps.chat.ui.ui_command import UICommand

if TYPE_CHECKING:
    from conduit.apps.chat.engine.async_engine import ChatEngine


class DemoInput(InputInterface):
    """
    A TUI-based input interface that splits the screen:
    - Top: Conversation History (Rich rendered)
    - Bottom: Input Buffer
    """

    def __init__(self, console: Console):
        self.console: Console = console
        self.engine: ChatEngine | None = None

        # --- 1. The Output Buffer (Top Pane) ---
        # We use a FormattedTextControl to display raw ANSI strings generated by Rich.
        self.output_control = FormattedTextControl(text="")
        self.output_window = Window(
            content=self.output_control,
            wrap_lines=True,
            always_hide_cursor=True,
            style="class:output-pane",
        )

        # --- 2. The Input Buffer (Bottom Pane) ---
        self.input_buffer = Buffer(multiline=True)  # Enable multiline input (Alt+Enter)
        self.input_control = BufferControl(buffer=self.input_buffer)
        self.input_window = Window(
            content=self.input_control,
            height=Dimension(min=3, max=6),  # Grow slightly if user types a lot
            style="class:input-pane",
            wrap_lines=True,
        )

        # --- 3. Layout ---
        self.root_container = HSplit(
            [
                # Top: Chat History (takes all remaining space)
                Frame(self.output_window, title=" Conduit Chat "),
                # Bottom: Input
                Frame(self.input_window, title=" Input (Alt+Enter for new line) "),
            ]
        )

        # --- 4. Key Bindings ---
        self.kb = KeyBindings()

        @self.kb.add("c-c")
        def _(event):
            "Quit application."
            event.app.exit(result=None)

        @self.kb.add("enter")
        def _(event):
            "Accept input. (If you want multiline by default, swap this with c-enter)"
            # Submit the buffer text and close the app loop temporarily
            text = self.input_buffer.text
            if text.strip():
                event.app.exit(result=text)

        # --- 5. Styles ---
        self.style = PtStyle.from_dict(
            {
                "output-pane": "bg:#000000 #ffffff",
                "input-pane": "",  # inherit default
                "frame.label": "bold #00ff00",
                "frame.border": "#444444",
            }
        )

        # --- 6. The Application Instance ---
        # Note: We don't run it yet. We run it inside get_input().
        self.app = Application(
            layout=Layout(self.root_container, focused_element=self.input_window),
            key_bindings=self.kb,
            style=self.style,
            full_screen=True,
            mouse_support=True,
        )

    def set_engine(self, engine: ChatEngine) -> None:
        """Dependency injection for the engine (to access history)."""
        self.engine = engine

    def _render_conversation_to_ansi(self) -> str:
        """
        Snapshot the current conversation state, render it with Rich to an
        in-memory buffer, and return the ANSI string.
        """
        if not self.engine:
            return ""

        # Create a memory buffer
        buf = io.StringIO()

        # Calculate width (subtracting border padding)
        width = shutil.get_terminal_size().columns - 4

        # Create a ephemeral console for this frame
        render_console = Console(
            file=buf,
            force_terminal=True,  # Crucial: forces ANSI generation
            color_system="truecolor",
            width=width,
            markup=True,
        )

        # Render the whole conversation
        if self.engine.conversation.messages:
            render_console.print(self.engine.conversation)
        else:
            render_console.print("[dim italic]No messages yet...[/dim italic]")

        return buf.getvalue()

    @override
    async def get_input(self, prompt: str = ">> ") -> str:
        """
        1. Refreshes the top pane with latest history.
        2. Clears previous input.
        3. Runs the TUI loop until user hits Enter.
        """

        # Update the view
        ansi_history = self._render_conversation_to_ansi()
        self.output_control.text = ANSI(ansi_history)

        # Clear the input box
        self.input_buffer.reset()

        # Hack to scroll to bottom:
        # Since FormattedTextControl is static, we rely on prompt_toolkit's
        # default layout engine to keep the cursor in view. But since focus
        # is on the Input Window, the Output Window might not scroll.
        # Ideally, we would use a specialized scrolling container here.
        # For this demo, let's see if the natural layout handles it.

        # Run the app!
        # This blocks (asynchronously) until app.exit() is called in keybindings.
        result = await self.app.run_async()

        return result

    @override
    def show_message(self, message: RenderableType, style: str = "info") -> None:
        """
        Fallback for startup messages before the loop starts.
        Once the loop runs, messages are shown via _render_conversation_to_ansi.
        """
        if not self.app.is_running:
            self.console.print(message)

    @override
    def execute_ui_command(self, command: UICommand) -> None:
        # TUI handles clearing and history internally
        pass

    @override
    def clear_screen(self) -> None:
        pass

    @override
    def clear_history_file(self) -> None:
        pass

    @override
    def exit(self) -> None:
        sys.exit(0)
